# Leetcode_record
小菜鸡刷题升级打怪历险记记录
Day1
做了3道简单基础的题目，其中两数之和是很久以前就刷过的，只不过没了太多印象，现在用python再刷了一遍。
这3道题都比较简单，不再赘述其他细节。

Day2
做了两道题。
第1道题是搜索插入位置，这道题一开始我使用的是普通的顺序查找，时间复杂度达到了O(n)，提交后才发现题目要求O(logn)，于是马上用二分查找进行订正，达到题目要求。
第2道题是一道经典的动态规划的题目，求最大子数组和，只要求返回sum的结果，不要求具体求出该子数组包含的元素。首次在刷leetcode的时候遇到动态规划的题，虽然是一道简单题，但是还是花了我很久的时间去思考，并且之后还是在看了解析的情况下终于有些“似懂非懂”了（这道题懂了，同类的题不保证会解决）

动态规划：应用与子问题重叠的情况，即不同的子问题具有公共的子子问题（子问题的求解是递归进行的，将其划分为更小的子子问题）。动态规划对于每一个子子问题只求解一次，将其解保存在一个表格里面，无需每次求解一个子子问题时都重新计算，避免不必要的计算工作。

动态规划的两个关键点：
1.理解题意
2.如何定义子问题（如何定义状态）和无后效性

题解思路：
1.设定一个dp数组用来保存当前遍历到的元素（包含该元素）之前的所有子数组和的最大值
2.遍历完所有数组后，即每一个元素都有一个对应的dp值
3.选出最大的dp值
该方法需要使用一个额外的数组空间来保存每一个元素的dp值，空间复杂度为O（n）

改进：用一个变量保存遍历到该变量前的子数组和的最大值，即用一个max_sum来保存当前元素前的最大dp值，若当前元素的dp值大于max_sum则进行替换。空间复杂度可降到O（1）
